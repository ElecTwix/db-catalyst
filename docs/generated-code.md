# Generated Code Reference

Complete guide to understanding and using code generated by db-catalyst. Learn about the generated types, interfaces, and patterns for effective database access.

## Table of Contents

- [Overview](#overview)
- [Generated Files](#generated-files)
- [Models](#models)
- [The Queries Struct](#the-queries-struct)
- [The DBTX Interface](#the-dbtx-interface)
- [Query Methods](#query-methods)
- [Transaction Support](#transaction-support)
- [Prepared Queries](#prepared-queries)
- [Configuration Options](#configuration-options)
- [Usage Patterns](#usage-patterns)
- [Working with Results](#working-with-results)
- [Advanced Patterns](#advanced-patterns)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Overview

db-catalyst generates idiomatic Go code that looks hand-written. The generated code provides:

- **Type-safe database access**: Compile-time checking of queries
- **Clean interfaces**: Easy to mock for testing
- **Context support**: First-class context.Context integration
- **Transaction support**: Seamless transaction handling
- **Prepared statements**: Optional prepared query caching

### Example Generated Code

Given this schema and query:

```sql
-- schema.sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- queries.sql
-- name: GetUser :one
SELECT * FROM users WHERE id = ?;

-- name: CreateUser :one
INSERT INTO users (email, name) VALUES (?, ?) RETURNING *;
```

db-catalyst generates code you can use like this:

```go
ctx := context.Background()
db, _ := sql.Open("sqlite3", "app.db")

queries := dbgen.New(db)

// Create a user
user, err := queries.CreateUser(ctx, "alice@example.com", "Alice")
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Created user: %d\n", user.ID)

// Get the user
fetched, err := queries.GetUser(ctx, user.ID)
if err == sql.ErrNoRows {
    fmt.Println("User not found")
}
```

## Generated Files

| File | Contents | Description |
|------|----------|-------------|
| `models.gen.go` | Table structs | Go structs representing database tables |
| `querier.gen.go` | Interface definitions | Querier and DBTX interfaces |
| `queries.gen.go` | Query implementations | Methods on the Queries struct |
| `prepared.gen.go` | Prepared statement wrapper | Optional prepared query support |
| `db.go` | Database helpers | New(), WithTx(), and utilities |

## Models

### Table Structs

Each table generates a struct with exported fields:

```go
// User represents a row in the users table.
type User struct {
    ID        int64
    Email     string
    Name      string
    CreatedAt *string  // nullable column
}
```

### Field Naming

- Column `id` → Field `ID`
- Column `email` → Field `Email`
- Column `created_at` → Field `CreatedAt`

### Nullable Fields

Columns without `NOT NULL` generate pointer types:

```sql
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,      -- string
    description TEXT,        -- *string (nullable)
    discontinued_at DATETIME -- *string (nullable)
);
```

```go
type Product struct {
    ID             int64
    Name           string
    Description    *string
    DiscontinuedAt *string
}
```

### JSON Tags

By default, structs include JSON tags:

```go
type User struct {
    ID        int64   `json:"id"`
    Email     string  `json:"email"`
    Name      string  `json:"name"`
    CreatedAt *string `json:"created_at"`
}
```

Disable JSON tags in config:

```toml
[generation]
emit_json_tags = false
```

### Custom Result Types

Queries with custom column selections generate result structs:

```sql
-- name: GetUserStats :one
SELECT 
    u.id,
    u.name,
    COUNT(p.id) as post_count
FROM users u
LEFT JOIN posts p ON p.author_id = u.id
WHERE u.id = ?
GROUP BY u.id, u.name;
```

```go
type GetUserStatsRow struct {
    ID        int64
    Name      string
    PostCount int64
}
```

Naming convention: `<QueryName>Row`

## The Queries Struct

### Basic Usage

```go
type Queries struct {
    db DBTX
}

func New(db DBTX) *Queries
```

The `Queries` struct holds a reference to your database connection:

```go
db, _ := sql.Open("sqlite3", "app.db")
queries := dbgen.New(db)
```

### The Querier Interface

All generated methods implement the `Querier` interface:

```go
type Querier interface {
    GetUser(ctx context.Context, id int64) (User, error)
    CreateUser(ctx context.Context, email string, name string) (User, error)
    ListUsers(ctx context.Context) ([]User, error)
    UpdateUser(ctx context.Context, id int64, email string, name string) error
    DeleteUser(ctx context.Context, id int64) error
}
```

This interface is perfect for:
- **Testing**: Mock the interface for unit tests
- **Dependency injection**: Pass `Querier` instead of `*Queries`
- **Abstraction**: Swap implementations

### Mocking for Tests

```go
// Mock implementation
type MockQueries struct {
    GetUserFunc func(ctx context.Context, id int64) (dbgen.User, error)
}

func (m *MockQueries) GetUser(ctx context.Context, id int64) (dbgen.User, error) {
    return m.GetUserFunc(ctx, id)
}

// Usage in test
mock := &MockQueries{
    GetUserFunc: func(ctx context.Context, id int64) (dbgen.User, error) {
        return dbgen.User{ID: id, Email: "test@example.com"}, nil
    },
}

// Pass mock to your service
service := NewUserService(mock)
```

## The DBTX Interface

### Definition

```go
type DBTX interface {
    ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
    QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
    QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}
```

### Implementations

Both `*sql.DB` and `*sql.Tx` implement `DBTX`:

```go
// Using a connection pool
db, _ := sql.Open("sqlite3", "app.db")
queries := dbgen.New(db)

// Using a transaction
tx, _ := db.BeginTx(ctx, nil)
queries = dbgen.New(tx)
```

### Why DBTX?

The `DBTX` interface enables:
1. **Transaction support**: Use same code for direct DB and transactions
2. **Testability**: Mock with `sqlmock` or custom implementations
3. **Flexibility**: Works with connection pools, transactions, or custom wrappers

## Query Methods

### :one Queries

Return a single struct or `sql.ErrNoRows`:

```sql
-- name: GetUser :one
SELECT * FROM users WHERE id = ?;
```

```go
func (q *Queries) GetUser(ctx context.Context, id int64) (User, error)
```

Usage:

```go
user, err := queries.GetUser(ctx, 1)
if err == sql.ErrNoRows {
    // Handle not found
    return nil, ErrUserNotFound
}
if err != nil {
    // Handle other errors
    return nil, err
}
// Use user
```

### :many Queries

Return a slice of structs (empty slice, never nil with `emit_empty_slices`):

```sql
-- name: ListUsers :many
SELECT * FROM users ORDER BY created_at DESC;
```

```go
func (q *Queries) ListUsers(ctx context.Context) ([]User, error)
```

Usage:

```go
users, err := queries.ListUsers(ctx)
if err != nil {
    return err
}
for _, user := range users {
    fmt.Println(user.Email)
}
```

### :exec Queries

Return only an error:

```sql
-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?;
```

```go
func (q *Queries) DeleteUser(ctx context.Context, id int64) error
```

Usage:

```go
if err := queries.DeleteUser(ctx, userID); err != nil {
    return err
}
```

### :execresult Queries

Return `sql.Result` for metadata:

```sql
-- name: CreateUser :execresult
INSERT INTO users (email, name) VALUES (?, ?);
```

```go
func (q *Queries) CreateUser(ctx context.Context, email string, name string) (sql.Result, error)
```

Usage:

```go
result, err := queries.CreateUser(ctx, "alice@example.com", "Alice")
if err != nil {
    return err
}

lastID, _ := result.LastInsertId()
rowsAffected, _ := result.RowsAffected()
```

## Transaction Support

### Basic Transactions

```go
func (s *UserService) TransferOwnership(ctx context.Context, fromID, toID int64) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // Create queries bound to transaction
    q := s.queries.WithTx(tx)

    // Perform operations
    if err := q.UpdatePostAuthor(ctx, fromID, toID); err != nil {
        return err
    }

    if err := q.CreateTransferLog(ctx, fromID, toID); err != nil {
        return err
    }

    return tx.Commit()
}
```

### WithTx Method

```go
func (q *Queries) WithTx(tx *sql.Tx) *Queries
```

Returns a new `Queries` instance bound to the transaction.

### Savepoints (Nested Transactions)

For complex operations within a transaction:

```go
tx, _ := db.BeginTx(ctx, nil)
defer tx.Rollback()

q := queries.WithTx(tx)

// Create savepoint
if _, err := tx.ExecContext(ctx, "SAVEPOINT before_update"); err != nil {
    return err
}

// Try operation
if err := q.RiskyOperation(ctx); err != nil {
    // Rollback to savepoint
    tx.ExecContext(ctx, "ROLLBACK TO SAVEPOINT before_update")
    return err
}

// Release savepoint
tx.ExecContext(ctx, "RELEASE SAVEPOINT before_update")

return tx.Commit()
```

## Prepared Queries

### Configuration

Enable prepared statement caching:

```toml
[prepared_queries]
enabled = true
thread_safe = true
metrics = false
```

### Generated Code

```go
type PreparedQueries struct {
    db    *sql.DB
    stmts map[string]*sql.Stmt
    mu    sync.RWMutex  // when thread_safe = true
}

func Prepare(ctx context.Context, db *sql.DB) (*PreparedQueries, error)
func (p *PreparedQueries) Close() error
```

### Usage

```go
// Prepare all statements once
db, _ := sql.Open("sqlite3", "app.db")
prepared, err := dbgen.Prepare(ctx, db)
if err != nil {
    log.Fatal(err)
}
defer prepared.Close()

// Use prepared queries
user, err := prepared.GetUser(ctx, 1)
```

### Thread Safety

With `thread_safe = true`:
- Safe for concurrent use
- Lazy statement preparation
- Mutex-protected cache

With `thread_safe = false`:
- Statements prepared eagerly in `Prepare()`
- No additional locking
- Slightly better performance for single-threaded use

### Metrics

With `metrics = true`, the generator creates hooks for observability:

```go
type PreparedMetricsRecorder interface {
    RecordQueryDuration(queryName string, duration time.Duration)
    RecordQueryError(queryName string, err error)
}
```

Implement and set:

```go
prepared.SetMetricsRecorder(myRecorder)
```

## Configuration Options

### Emit Empty Slices

Return empty slices instead of nil for `:many` queries:

```toml
[generation]
emit_empty_slices = true
```

```go
// Without emit_empty_slices
users, _ := queries.ListUsers(ctx)
// users == nil when no results

// With emit_empty_slices
users, _ := queries.ListUsers(ctx)
// users == []User{} when no results
```

### Emit Pointers for Null

Generate pointer types for nullable columns:

```toml
[generation]
emit_pointers_for_null = true
```

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    email TEXT NOT NULL,  -- always string
    bio TEXT              -- *string when nullable
);
```

### JSON Tags

Control JSON tag generation:

```toml
[generation]
emit_json_tags = true   # default
# or
emit_json_tags = false  # no json tags
```

### SQL Dialect Output

Generate SQL schema for different databases:

```toml
[generation]
sql_dialect = "postgres"  # sqlite, mysql, postgres
```

## Usage Patterns

### Repository Pattern

```go
// Repository interface
type UserRepository interface {
    GetByID(ctx context.Context, id int64) (*User, error)
    GetByEmail(ctx context.Context, email string) (*User, error)
    Create(ctx context.Context, email, name string) (*User, error)
    Update(ctx context.Context, id int64, updates UserUpdates) (*User, error)
    Delete(ctx context.Context, id int64) error
    List(ctx context.Context, opts ListOptions) ([]User, error)
}

// Implementation using generated code
type userRepo struct {
    queries *dbgen.Queries
}

func (r *userRepo) GetByID(ctx context.Context, id int64) (*User, error) {
    u, err := r.queries.GetUser(ctx, id)
    if err == sql.ErrNoRows {
        return nil, ErrNotFound
    }
    if err != nil {
        return nil, err
    }
    return &User{
        ID:    u.ID,
        Email: u.Email,
        Name:  u.Name,
    }, nil
}
```

### Service Layer

```go
type UserService struct {
    queries dbgen.Querier
    db      *sql.DB
}

func (s *UserService) CreateUser(ctx context.Context, email, name string) (*User, error) {
    // Validation
    if email == "" || name == "" {
        return nil, ErrInvalidInput
    }

    // Create in transaction
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()

    q := s.queries.WithTx(tx)

    user, err := q.CreateUser(ctx, email, name)
    if err != nil {
        if isDuplicateError(err) {
            return nil, ErrEmailExists
        }
        return nil, err
    }

    if err := q.CreateUserProfile(ctx, user.ID); err != nil {
        return nil, err
    }

    if err := tx.Commit(); err != nil {
        return nil, err
    }

    return &User{
        ID:    user.ID,
        Email: user.Email,
        Name:  user.Name,
    }, nil
}
```

### HTTP Handler

```go
func (h *Handler) GetUser(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    idStr := chi.URLParam(r, "id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        http.Error(w, "Invalid ID", http.StatusBadRequest)
        return
    }

    user, err := h.queries.GetUser(ctx, id)
    if err == sql.ErrNoRows {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}
```

## Working with Results

### Handling NULL Values

```go
user, err := queries.GetUser(ctx, id)
if err != nil {
    return err
}

// Check nullable field
if user.Bio != nil {
    fmt.Printf("Bio: %s\n", *user.Bio)
} else {
    fmt.Println("No bio")
}
```

### Converting Types

```go
// String to int
id, _ := strconv.ParseInt(userIDStr, 10, 64)
user, _ := queries.GetUser(ctx, id)

// Time parsing
if user.CreatedAt != nil {
    t, _ := time.Parse(time.RFC3339, *user.CreatedAt)
    fmt.Printf("Created: %v\n", t)
}
```

### Working with Slices

```go
users, err := queries.ListUsers(ctx)
if err != nil {
    return err
}

// Safe iteration (works with nil or empty)
for _, user := range users {
    fmt.Println(user.Email)
}

// Check emptiness
if len(users) == 0 {
    fmt.Println("No users found")
}

// Convert to different type
emails := make([]string, len(users))
for i, u := range users {
    emails[i] = u.Email
}
```

## Advanced Patterns

### Connection Pooling

```go
db, err := sql.Open("sqlite3", "app.db")
if err != nil {
    log.Fatal(err)
}

// Configure pool
db.SetMaxOpenConns(25)
db.SetMaxIdleConns(25)
db.SetConnMaxLifetime(5 * time.Minute)

queries := dbgen.New(db)
```

### Context Cancellation

```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

user, err := queries.GetUser(ctx, id)
if err == context.DeadlineExceeded {
    // Handle timeout
}
```

### Bulk Operations

```go
func (s *Service) BulkCreateUsers(ctx context.Context, users []NewUser) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    q := s.queries.WithTx(tx)

    for _, u := range users {
        if _, err := q.CreateUser(ctx, u.Email, u.Name); err != nil {
            return fmt.Errorf("create user %s: %w", u.Email, err)
        }
    }

    return tx.Commit()
}
```

### Query Timeouts

```go
func (s *Service) GetUserWithTimeout(ctx context.Context, id int64) (dbgen.User, error) {
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()

    return s.queries.GetUser(ctx, id)
}
```

## Best Practices

### 1. Always Check for sql.ErrNoRows

```go
user, err := queries.GetUser(ctx, id)
if err == sql.ErrNoRows {
    return nil, ErrUserNotFound
}
if err != nil {
    return nil, err
}
```

### 2. Use Transactions for Multiple Operations

```go
tx, err := db.BeginTx(ctx, nil)
if err != nil {
    return err
}
defer tx.Rollback()

q := queries.WithTx(tx)
// ... perform operations

if err := tx.Commit(); err != nil {
    return err
}
```

### 3. Pass Context Through Your Application

```go
// Good
func (s *Service) GetUser(ctx context.Context, id int64) (*User, error) {
    return s.queries.GetUser(ctx, id)
}

// Avoid - use context.Background() sparingly
func (s *Service) GetUser(id int64) (*User, error) {
    return s.queries.GetUser(context.Background(), id)
}
```

### 4. Handle NULL Values Explicitly

```go
bio := ""
if user.Bio != nil {
    bio = *user.Bio
}
```

### 5. Use the Querier Interface

```go
// Good - accept interface
type UserService struct {
    queries dbgen.Querier
}

// Avoid - concrete type
type UserService struct {
    queries *dbgen.Queries
}
```

### 6. Close Prepared Queries

```go
prepared, err := dbgen.Prepare(ctx, db)
if err != nil {
    return err
}
defer prepared.Close()  // Always close
```

## Troubleshooting

### Common Issues

**Issue**: `sql: converting argument $1 type: unsupported type`
- **Solution**: Ensure parameter types match the expected types. Use proper Go types (int64, not int).

**Issue**: `sql: no rows in result set` not being caught
- **Solution**: Compare with `sql.ErrNoRows`, not the error string:
  ```go
  if err == sql.ErrNoRows  // Correct
  if err.Error() == "sql: no rows in result set"  // Fragile
  ```

**Issue**: Transaction not rolling back on panic
- **Solution**: Use defer with named return to check error:
  ```go
  func (s *Service) DoSomething(ctx context.Context) (err error) {
      tx, _ := s.db.BeginTx(ctx, nil)
      defer func() {
          if err != nil {
              tx.Rollback()
          }
      }()
      // ... operations
      return tx.Commit()
  }
  ```

**Issue**: Prepared queries not thread-safe
- **Solution**: Enable `thread_safe = true` in config or ensure single-threaded access.

**Issue**: Nil pointer dereference with nullable columns
- **Solution**: Always check for nil before dereferencing:
  ```go
  if user.Bio != nil {
      fmt.Println(*user.Bio)
  }
  ```

---

For more information, see:
- [Schema Reference](schema.md) - Defining database schemas
- [Query Reference](query.md) - Writing SQL queries
- [Feature Flags](feature-flags.md) - Configuration options
