# Schema Reference

db-catalyst generates Go types from SQLite schema definitions and can output SQL schema for SQLite, MySQL, and PostgreSQL.

## Supported Syntax

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## Column Types

| SQLite Type | Go Type |
|-------------|---------|
| INTEGER | int64 |
| REAL | float64 |
| TEXT | string |
| BLOB | []byte |
| NUMERIC | float64 |

## Nullable Columns

Columns without `NOT NULL` are generated as pointers:

```sql
email TEXT          -- nullable → *string
age INTEGER         -- nullable → *int64
```

## Default Values

Default values are supported but ignored during code generation. SQLite handles defaults at runtime.

## CHECK Constraints

CHECK constraints are parsed but ignored. They don't affect generated code.

## PRIMARY KEY

- `INTEGER PRIMARY KEY` becomes the table's primary key type
- `PRIMARY KEY` on other columns doesn't change type generation

## STRICT Tables

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
) STRICT, WITHOUT ROWID;
```

STRICT tables are fully supported. Type checking happens at insert time in SQLite.

## Generating Models

Models are generated from tables referenced in queries:

```sql
-- name: GetUser :one
SELECT * FROM users WHERE id = ?;
```

Generates `models.gen.go` with the `User` struct.

---

# SQL Schema Generation

db-catalyst can generate normalized SQL schema from your parsed schema model for deployment to different databases.

## Configuration

```toml
[generation]
sql_dialect = "sqlite"   # sqlite, mysql, or postgres
```

Or via CLI:

```bash
db-catalyst --sql-dialect postgres
```

## Supported Dialects

| Dialect | Identifier | Output |
|---------|------------|--------|
| SQLite | `sqlite` | `CREATE TABLE IF NOT EXISTS ...` |
| MySQL | `mysql` | `DROP TABLE IF EXISTS ...` with `ENGINE=InnoDB` |
| PostgreSQL | `postgres` | `DROP TABLE IF EXISTS ...` with `GENERATED ALWAYS AS IDENTITY` |

## SQLite Output

```sql
-- Auto-generated schema for sqlite
-- Generated by db-catalyst

CREATE TABLE IF NOT EXISTS users (
    id INTEGER NOT NULL,
    email TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE (email)
);

CREATE TABLE IF NOT EXISTS posts (
    id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    body TEXT,
    PRIMARY KEY (id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts(user_id);
```

**SQLite Features:**
- `CREATE TABLE IF NOT EXISTS`
- `STRICT` and `WITHOUT ROWID` table options
- Inline `PRIMARY KEY` and `FOREIGN KEY`
- `UNIQUE` constraints
- `CREATE INDEX IF NOT EXISTS`

## MySQL Output

```sql
-- Auto-generated schema for mysql
-- Generated by db-catalyst

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

DROP TABLE IF EXISTS users;
CREATE TABLE IF NOT EXISTS users (
    id BIGINT NOT NULL AUTO_INCREMENT,
    email TEXT NOT NULL,
    created_at TEXT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY users_email_key (email)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DROP TABLE IF EXISTS posts;
CREATE TABLE IF NOT EXISTS posts (
    id BIGINT NOT NULL AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    title TEXT NOT NULL,
    body TEXT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (user_id) REFERENCES users(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE INDEX idx_posts_user_id ON posts(user_id);
SET FOREIGN_KEY_CHECKS = 1;
```

**MySQL Features:**
- `DROP TABLE IF EXISTS` for clean re-creation
- `AUTO_INCREMENT` for `id` columns
- Explicit `NULL`/`NOT NULL`
- `UNIQUE KEY` constraint naming
- `ENGINE=InnoDB` with `utf8mb4` charset
- `SET FOREIGN_KEY_CHECKS = 0/1` for referential integrity

## PostgreSQL Output

```sql
-- Auto-generated schema for postgres
-- Generated by db-catalyst

DROP TABLE IF EXISTS users;
CREATE TABLE IF NOT EXISTS users (
    id INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY,
    email TEXT NOT NULL,
    created_at TEXT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    CONSTRAINT users_email_key UNIQUE (email)
);

DROP TABLE IF EXISTS posts;
CREATE TABLE IF NOT EXISTS posts (
    id INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    body TEXT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_posts_user_id ON posts(user_id);
```

**PostgreSQL Features:**
- `DROP TABLE IF EXISTS` for clean re-creation
- `GENERATED ALWAYS AS IDENTITY` for auto-increment
- Explicit `NULL`/`NOT NULL`
- `CONSTRAINT name UNIQUE (cols)` syntax
- Standard `CREATE INDEX` / `CREATE UNIQUE INDEX`

## Type Mapping by Dialect

### SQLite Types

| Input Type | Output Type |
|------------|-------------|
| INTEGER, INT, BIGINT | INTEGER |
| REAL, FLOAT, DOUBLE | REAL |
| TEXT, VARCHAR, CHAR | TEXT |
| BLOB | BLOB |
| BOOLEAN | INTEGER |

### MySQL Types

| Input Type | Output Type |
|------------|-------------|
| INTEGER, INT, BIGINT | BIGINT |
| REAL, FLOAT, DOUBLE | DOUBLE |
| TEXT, VARCHAR, CHAR | TEXT (preserves length) |
| BLOB | BLOB |
| BOOLEAN | TINYINT(1) |
| DATETIME, TIMESTAMP | DATETIME |
| JSON | JSON |

### PostgreSQL Types

| Input Type | Output Type |
|------------|-------------|
| INTEGER, INT | INTEGER |
| BIGINT | BIGINT |
| REAL, FLOAT4 | REAL |
| DOUBLE, FLOAT8 | DOUBLE PRECISION |
| DECIMAL, NUMERIC | NUMERIC |
| TEXT, VARCHAR | TEXT (preserves length) |
| BLOB | BYTEA |
| BOOLEAN | BOOLEAN |
| DATETIME, TIMESTAMP | TIMESTAMP |
| DATE | DATE |
| TIME | TIME |
| JSON | JSON |
| JSONB | JSONB |
| UUID | UUID |
| SERIAL | SERIAL |
| BIGSERIAL | BIGSERIAL |

## Views

Views are generated separately for each dialect:

```sql
-- SQLite
CREATE VIEW active_users AS
SELECT * FROM users WHERE active = 1;

-- MySQL
CREATE OR REPLACE VIEW active_users AS
SELECT * FROM users WHERE active = 1;

-- PostgreSQL  
CREATE OR REPLACE VIEW active_users AS
SELECT * FROM users WHERE active = 1;
```

Views are output to `views/<view_name>.sql`.

## CLI Options

```bash
--sql-dialect string   Generate SQL schema output (sqlite, mysql, postgres)
--sql-output           Enable SQL schema generation
--if-not-exists        Use IF NOT EXISTS in SQL output (default true)
```
