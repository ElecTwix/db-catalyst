package store

import (
	"context"
	"database/sql"
	"sync"
	"time"
)

type PrepareDB interface {
	DBTX
	PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)
}

type PreparedMetricsRecorder interface {
	ObservePreparedQuery(ctx context.Context, name string, duration time.Duration, err error)
}

type PreparedConfig struct {
	Metrics PreparedMetricsRecorder
}

type PreparedQueries struct {
	queries                 *Queries
	db                      PrepareDB
	metrics                 PreparedMetricsRecorder
	closeOnce               sync.Once
	closeErr                error
	stmtCreateUser          *sql.Stmt
	stmtCreateUserMu        sync.Mutex
	stmtDeleteUser          *sql.Stmt
	stmtDeleteUserMu        sync.Mutex
	stmtGetUser             *sql.Stmt
	stmtGetUserMu           sync.Mutex
	stmtListUsers           *sql.Stmt
	stmtListUsersMu         sync.Mutex
	stmtListUsersByIDs      *sql.Stmt
	stmtListUsersByIDsMu    sync.Mutex
	stmtSummarizeCredits    *sql.Stmt
	stmtSummarizeCreditsMu  sync.Mutex
	stmtUpdateUserCredits   *sql.Stmt
	stmtUpdateUserCreditsMu sync.Mutex
}

func (p *PreparedQueries) Raw() *Queries {
	return p.queries
}

func Prepare(ctx context.Context, db PrepareDB, cfg PreparedConfig) (*PreparedQueries, error) {
	pq := &PreparedQueries{
		queries: New(db),
		db:      db,
		metrics: cfg.Metrics,
	}
	return pq, nil
}

func (p *PreparedQueries) Close() error {
	p.closeOnce.Do(func() {
		var err error
		p.stmtCreateUserMu.Lock()
		if p.stmtCreateUser != nil {
			if closeErr := p.stmtCreateUser.Close(); err == nil && closeErr != nil {
				err = closeErr
			}
			p.stmtCreateUser = nil
		}
		p.stmtCreateUserMu.Unlock()
		p.stmtDeleteUserMu.Lock()
		if p.stmtDeleteUser != nil {
			if closeErr := p.stmtDeleteUser.Close(); err == nil && closeErr != nil {
				err = closeErr
			}
			p.stmtDeleteUser = nil
		}
		p.stmtDeleteUserMu.Unlock()
		p.stmtGetUserMu.Lock()
		if p.stmtGetUser != nil {
			if closeErr := p.stmtGetUser.Close(); err == nil && closeErr != nil {
				err = closeErr
			}
			p.stmtGetUser = nil
		}
		p.stmtGetUserMu.Unlock()
		p.stmtListUsersMu.Lock()
		if p.stmtListUsers != nil {
			if closeErr := p.stmtListUsers.Close(); err == nil && closeErr != nil {
				err = closeErr
			}
			p.stmtListUsers = nil
		}
		p.stmtListUsersMu.Unlock()
		p.stmtListUsersByIDsMu.Lock()
		if p.stmtListUsersByIDs != nil {
			if closeErr := p.stmtListUsersByIDs.Close(); err == nil && closeErr != nil {
				err = closeErr
			}
			p.stmtListUsersByIDs = nil
		}
		p.stmtListUsersByIDsMu.Unlock()
		p.stmtSummarizeCreditsMu.Lock()
		if p.stmtSummarizeCredits != nil {
			if closeErr := p.stmtSummarizeCredits.Close(); err == nil && closeErr != nil {
				err = closeErr
			}
			p.stmtSummarizeCredits = nil
		}
		p.stmtSummarizeCreditsMu.Unlock()
		p.stmtUpdateUserCreditsMu.Lock()
		if p.stmtUpdateUserCredits != nil {
			if closeErr := p.stmtUpdateUserCredits.Close(); err == nil && closeErr != nil {
				err = closeErr
			}
			p.stmtUpdateUserCredits = nil
		}
		p.stmtUpdateUserCreditsMu.Unlock()
		p.closeErr = err
	})
	return p.closeErr
}

func (p *PreparedQueries) prepareCreateUser(ctx context.Context) (*sql.Stmt, error) {
	if stmt := p.stmtCreateUser; stmt != nil {
		return stmt, nil
	}
	p.stmtCreateUserMu.Lock()
	defer p.stmtCreateUserMu.Unlock()
	if stmt := p.stmtCreateUser; stmt != nil {
		return stmt, nil
	}
	stmt, err := p.db.PrepareContext(ctx, queryCreateUser)
	if err != nil {
		return nil, err
	}
	p.stmtCreateUser = stmt
	return stmt, nil
}

func (p *PreparedQueries) prepareDeleteUser(ctx context.Context) (*sql.Stmt, error) {
	if stmt := p.stmtDeleteUser; stmt != nil {
		return stmt, nil
	}
	p.stmtDeleteUserMu.Lock()
	defer p.stmtDeleteUserMu.Unlock()
	if stmt := p.stmtDeleteUser; stmt != nil {
		return stmt, nil
	}
	stmt, err := p.db.PrepareContext(ctx, queryDeleteUser)
	if err != nil {
		return nil, err
	}
	p.stmtDeleteUser = stmt
	return stmt, nil
}

func (p *PreparedQueries) prepareGetUser(ctx context.Context) (*sql.Stmt, error) {
	if stmt := p.stmtGetUser; stmt != nil {
		return stmt, nil
	}
	p.stmtGetUserMu.Lock()
	defer p.stmtGetUserMu.Unlock()
	if stmt := p.stmtGetUser; stmt != nil {
		return stmt, nil
	}
	stmt, err := p.db.PrepareContext(ctx, queryGetUser)
	if err != nil {
		return nil, err
	}
	p.stmtGetUser = stmt
	return stmt, nil
}

func (p *PreparedQueries) prepareListUsers(ctx context.Context) (*sql.Stmt, error) {
	if stmt := p.stmtListUsers; stmt != nil {
		return stmt, nil
	}
	p.stmtListUsersMu.Lock()
	defer p.stmtListUsersMu.Unlock()
	if stmt := p.stmtListUsers; stmt != nil {
		return stmt, nil
	}
	stmt, err := p.db.PrepareContext(ctx, queryListUsers)
	if err != nil {
		return nil, err
	}
	p.stmtListUsers = stmt
	return stmt, nil
}

func (p *PreparedQueries) prepareListUsersByIDs(ctx context.Context) (*sql.Stmt, error) {
	if stmt := p.stmtListUsersByIDs; stmt != nil {
		return stmt, nil
	}
	p.stmtListUsersByIDsMu.Lock()
	defer p.stmtListUsersByIDsMu.Unlock()
	if stmt := p.stmtListUsersByIDs; stmt != nil {
		return stmt, nil
	}
	stmt, err := p.db.PrepareContext(ctx, queryListUsersByIDs)
	if err != nil {
		return nil, err
	}
	p.stmtListUsersByIDs = stmt
	return stmt, nil
}

func (p *PreparedQueries) prepareSummarizeCredits(ctx context.Context) (*sql.Stmt, error) {
	if stmt := p.stmtSummarizeCredits; stmt != nil {
		return stmt, nil
	}
	p.stmtSummarizeCreditsMu.Lock()
	defer p.stmtSummarizeCreditsMu.Unlock()
	if stmt := p.stmtSummarizeCredits; stmt != nil {
		return stmt, nil
	}
	stmt, err := p.db.PrepareContext(ctx, querySummarizeCredits)
	if err != nil {
		return nil, err
	}
	p.stmtSummarizeCredits = stmt
	return stmt, nil
}

func (p *PreparedQueries) prepareUpdateUserCredits(ctx context.Context) (*sql.Stmt, error) {
	if stmt := p.stmtUpdateUserCredits; stmt != nil {
		return stmt, nil
	}
	p.stmtUpdateUserCreditsMu.Lock()
	defer p.stmtUpdateUserCreditsMu.Unlock()
	if stmt := p.stmtUpdateUserCredits; stmt != nil {
		return stmt, nil
	}
	stmt, err := p.db.PrepareContext(ctx, queryUpdateUserCredits)
	if err != nil {
		return nil, err
	}
	p.stmtUpdateUserCredits = stmt
	return stmt, nil
}

func (p *PreparedQueries) CreateUser(ctx context.Context, email sql.NullString, credits sql.NullFloat64) (sql.Result, error) {
	stmt, err := p.prepareCreateUser(ctx)
	if err != nil {
		return nil, err
	}
	recorder := p.metrics
	var start time.Time
	if recorder != nil {
		start = time.Now()
	}
	res, err := stmt.ExecContext(ctx, email, credits)
	if recorder != nil {
		recorder.ObservePreparedQuery(ctx, "CreateUser", time.Since(start), err)
	}
	return res, err
}

func (p *PreparedQueries) DeleteUser(ctx context.Context, id int64) (QueryResult, error) {
	stmt, err := p.prepareDeleteUser(ctx)
	if err != nil {
		return QueryResult{}, err
	}
	recorder := p.metrics
	var start time.Time
	if recorder != nil {
		start = time.Now()
	}
	res, err := stmt.ExecContext(ctx, id)
	if recorder != nil {
		recorder.ObservePreparedQuery(ctx, "DeleteUser", time.Since(start), err)
	}
	if err != nil {
		return QueryResult{}, err
	}
	result := QueryResult{}
	if v, err := res.LastInsertId(); err == nil {
		result.LastInsertID = v
	}
	if v, err := res.RowsAffected(); err == nil {
		result.RowsAffected = v
	}
	return result, nil
}

// GetUser fetches a single user by identifier.
func (p *PreparedQueries) GetUser(ctx context.Context, id int64) (GetUserRow, error) {
	stmt, err := p.prepareGetUser(ctx)
	if err != nil {
		return GetUserRow{}, err
	}
	recorder := p.metrics
	var start time.Time
	if recorder != nil {
		start = time.Now()
	}
	rows, err := stmt.QueryContext(ctx, id)
	if recorder != nil {
		recorder.ObservePreparedQuery(ctx, "GetUser", time.Since(start), err)
	}
	if err != nil {
		return GetUserRow{}, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return GetUserRow{}, err
		}
		return GetUserRow{}, sql.ErrNoRows
	}
	item, err := scanGetUserRow(rows)
	if err != nil {
		return item, err
	}
	if err := rows.Err(); err != nil {
		return item, err
	}
	return item, nil
}

func (p *PreparedQueries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	stmt, err := p.prepareListUsers(ctx)
	if err != nil {
		return nil, err
	}
	recorder := p.metrics
	var start time.Time
	if recorder != nil {
		start = time.Now()
	}
	rows, err := stmt.QueryContext(ctx)
	if recorder != nil {
		recorder.ObservePreparedQuery(ctx, "ListUsers", time.Since(start), err)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := make([]ListUsersRow, 0)
	for rows.Next() {
		item, err := scanListUsersRow(rows)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

func (p *PreparedQueries) ListUsersByIDs(ctx context.Context, ids ...int64) ([]ListUsersByIDsRow, error) {
	stmt, err := p.prepareListUsersByIDs(ctx)
	if err != nil {
		return nil, err
	}
	recorder := p.metrics
	var start time.Time
	if recorder != nil {
		start = time.Now()
	}
	idsArgs := make([]any, len(ids))
	for i := range ids {
		idsArgs[i] = ids[i]
	}
	rows, err := stmt.QueryContext(ctx, idsArgs...)
	if recorder != nil {
		recorder.ObservePreparedQuery(ctx, "ListUsersByIDs", time.Since(start), err)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := make([]ListUsersByIDsRow, 0)
	for rows.Next() {
		item, err := scanListUsersByIDsRow(rows)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// SummarizeCredits aggregates user credits across a recursive rollup.
func (p *PreparedQueries) SummarizeCredits(ctx context.Context) (SummarizeCreditsRow, error) {
	stmt, err := p.prepareSummarizeCredits(ctx)
	if err != nil {
		return SummarizeCreditsRow{}, err
	}
	recorder := p.metrics
	var start time.Time
	if recorder != nil {
		start = time.Now()
	}
	rows, err := stmt.QueryContext(ctx)
	if recorder != nil {
		recorder.ObservePreparedQuery(ctx, "SummarizeCredits", time.Since(start), err)
	}
	if err != nil {
		return SummarizeCreditsRow{}, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return SummarizeCreditsRow{}, err
		}
		return SummarizeCreditsRow{}, sql.ErrNoRows
	}
	item, err := scanSummarizeCreditsRow(rows)
	if err != nil {
		return item, err
	}
	if err := rows.Err(); err != nil {
		return item, err
	}
	return item, nil
}

func (p *PreparedQueries) UpdateUserCredits(ctx context.Context, credits sql.NullFloat64, id int64) (sql.Result, error) {
	stmt, err := p.prepareUpdateUserCredits(ctx)
	if err != nil {
		return nil, err
	}
	recorder := p.metrics
	var start time.Time
	if recorder != nil {
		start = time.Now()
	}
	res, err := stmt.ExecContext(ctx, credits, id)
	if recorder != nil {
		recorder.ObservePreparedQuery(ctx, "UpdateUserCredits", time.Since(start), err)
	}
	return res, err
}
