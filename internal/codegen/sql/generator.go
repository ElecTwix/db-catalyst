// Package sql generates SQL schema definitions from a database catalog.
// It supports multiple SQL dialects including SQLite, MySQL, and PostgreSQL.
//
//nolint:goconst // SQL type names are naturally repeated and don't need constants
package sql

import (
	"bytes"
	"fmt"
	"slices"
	"strings"

	"github.com/electwix/db-catalyst/internal/schema/model"
)

// Dialect represents the target SQL database dialect.
type Dialect string

const (
	// DialectSQLite generates SQLite-compatible SQL.
	DialectSQLite Dialect = "sqlite"
	// DialectMySQL generates MySQL-compatible SQL.
	DialectMySQL Dialect = "mysql"
	// DialectPostgres generates PostgreSQL-compatible SQL.
	DialectPostgres Dialect = "postgres"
)

// Generator produces SQL schema files from a database catalog.
type Generator struct {
	dialect         Dialect
	emitIFNotExists bool
}

// Options configures the SQL generator.
type Options struct {
	// Dialect specifies the target SQL dialect.
	Dialect Dialect
	// EmitIFNotExists controls whether IF NOT EXISTS clauses are generated.
	EmitIFNotExists bool
	// EmitComments controls whether comments are included in output.
	EmitComments bool
}

// New creates a new SQL generator with the specified options.
func New(opts Options) *Generator {
	g := &Generator{
		dialect:         opts.Dialect,
		emitIFNotExists: opts.EmitIFNotExists,
	}
	if g.dialect == "" {
		g.dialect = DialectSQLite
	}
	return g
}

// Generate creates SQL schema files from the given catalog.
func (g *Generator) Generate(catalog *model.Catalog) ([]File, error) {
	var files []File

	if len(catalog.Tables) > 0 {
		var buf bytes.Buffer
		switch g.dialect {
		case DialectSQLite:
			g.generateSQLiteSchema(&buf, catalog)
		case DialectMySQL:
			g.generateMySQLSchema(&buf, catalog)
		case DialectPostgres:
			g.generatePostgresSchema(&buf, catalog)
		}
		files = append(files, File{
			Path:    "schema.gen.sql",
			Content: buf.Bytes(),
		})
	}

	for _, view := range catalog.Views {
		var buf bytes.Buffer
		switch g.dialect {
		case DialectSQLite:
			g.generateSQLiteView(&buf, view)
		case DialectMySQL:
			g.generateMySQLView(&buf, view)
		case DialectPostgres:
			g.generatePostgresView(&buf, view)
		}
		files = append(files, File{
			Path:    fmt.Sprintf("views/%s.sql", sanitizeName(view.Name)),
			Content: buf.Bytes(),
		})
	}

	return files, nil
}

// File represents a generated SQL file.
type File struct {
	Path    string
	Content []byte
}

func (g *Generator) generateSQLiteSchema(buf *bytes.Buffer, catalog *model.Catalog) {
	buf.WriteString("-- Auto-generated schema for ")
	buf.WriteString(string(g.dialect))
	buf.WriteString("\n")
	buf.WriteString("-- Generated by db-catalyst\n\n")

	tables := g.sortedTables(catalog)
	for _, table := range tables {
		g.writeSQLiteTable(buf, table)
		buf.WriteString("\n")
	}

	for _, idx := range tableIndexes(catalog) {
		if !idx.Unique {
			buf.WriteString(g.generateSQLiteIndex(idx, catalog))
			buf.WriteString("\n")
		}
	}

	for _, table := range tables {
		for _, idx := range table.Indexes {
			if idx.Unique {
				buf.WriteString(g.generateSQLiteUniqueIndex(table.Name, idx))
				buf.WriteString("\n")
			}
		}
	}
}

func (g *Generator) writeSQLiteTable(buf *bytes.Buffer, table *model.Table) {
	buf.WriteString("CREATE TABLE IF NOT EXISTS ")
	buf.WriteString(table.Name)
	buf.WriteString(" (\n")

	var clauses []string
	for _, col := range table.Columns {
		clause := "    " + g.sqliteColumnDefinition(col)
		clauses = append(clauses, clause)
	}

	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := strings.Join(table.PrimaryKey.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    PRIMARY KEY (%s)", pkCols))
	}

	for _, fk := range table.ForeignKeys {
		refCols := strings.Join(fk.Ref.Columns, ", ")
		fkCols := strings.Join(fk.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    FOREIGN KEY (%s) REFERENCES %s(%s)", fkCols, fk.Ref.Table, refCols))
	}

	for _, uk := range table.UniqueKeys {
		cols := strings.Join(uk.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    UNIQUE (%s)", cols))
	}

	for i, clause := range clauses {
		buf.WriteString(clause)
		if i < len(clauses)-1 {
			buf.WriteString(",")
		}
		buf.WriteString("\n")
	}

	buf.WriteString(")")

	if table.Strict {
		buf.WriteString(" STRICT")
	}
	if table.WithoutRowID {
		buf.WriteString(" WITHOUT ROWID")
	}
	buf.WriteString(";")

	if table.Doc != "" {
		buf.WriteString(" -- ")
		buf.WriteString(table.Doc)
	}
	buf.WriteString("\n")
}

func (g *Generator) sqliteColumnDefinition(col *model.Column) string {
	var parts []string

	parts = append(parts, col.Name)
	parts = append(parts, g.sqliteColumnType(col.Type))

	if col.NotNull {
		parts = append(parts, "NOT NULL")
	}

	if col.Default != nil {
		parts = append(parts, "DEFAULT "+g.sqliteDefaultValue(col.Default))
	}

	return strings.Join(parts, " ")
}

func (g *Generator) sqliteColumnType(typ string) string {
	upper := strings.ToUpper(typ)
	switch upper {
	case "INTEGER", "INT", "BIGINT", "SMALLINT", "TINYINT":
		return "INTEGER"
	case "REAL", "FLOAT", "DOUBLE", "DECIMAL", "NUMERIC":
		return "REAL"
	case "TEXT", "VARCHAR", "CHAR", "CLOB":
		return "TEXT"
	case "BLOB":
		return "BLOB"
	case "BOOLEAN", "BOOL":
		return "INTEGER"
	default:
		if strings.HasPrefix(upper, "VARCHAR") || strings.HasPrefix(upper, "CHAR") ||
			strings.HasPrefix(upper, "TEXT") || strings.HasPrefix(upper, "NVARCHAR") {
			return "TEXT"
		}
		if strings.HasPrefix(upper, "INT") {
			return "INTEGER"
		}
		return typ
	}
}

func (g *Generator) sqliteDefaultValue(v *model.Value) string {
	switch v.Kind {
	case model.ValueKindNumber:
		return v.Text
	case model.ValueKindString:
		return "'" + v.Text + "'"
	case model.ValueKindKeyword:
		upper := strings.ToUpper(v.Text)
		if upper == "CURRENT_TIMESTAMP" || upper == "CURRENT_DATE" || upper == "CURRENT_TIME" {
			return upper
		}
		return v.Text
	case model.ValueKindBlob:
		return v.Text
	default:
		return "NULL"
	}
}

func (g *Generator) generateSQLiteIndex(idx *model.Index, catalog *model.Catalog) string {
	tableName := findTableForIndex(catalog, idx)
	cols := strings.Join(idx.Columns, ", ")
	return fmt.Sprintf("CREATE INDEX IF NOT EXISTS %s ON %s(%s);", idx.Name, tableName, cols)
}

func (g *Generator) generateSQLiteUniqueIndex(tableName string, idx *model.Index) string {
	cols := strings.Join(idx.Columns, ", ")
	return fmt.Sprintf("CREATE UNIQUE INDEX IF NOT EXISTS %s ON %s(%s);", idx.Name, tableName, cols)
}

func (g *Generator) generateSQLiteView(buf *bytes.Buffer, view *model.View) {
	buf.WriteString("CREATE VIEW ")
	buf.WriteString(view.Name)
	buf.WriteString(" AS\n")
	buf.WriteString(view.SQL)
	buf.WriteString(";\n")
}

func (g *Generator) generateMySQLSchema(buf *bytes.Buffer, catalog *model.Catalog) {
	buf.WriteString("-- Auto-generated schema for ")
	buf.WriteString(string(g.dialect))
	buf.WriteString("\n")
	buf.WriteString("-- Generated by db-catalyst\n\n")

	buf.WriteString("SET NAMES utf8mb4;\n")
	buf.WriteString("SET FOREIGN_KEY_CHECKS = 0;\n\n")

	tables := g.sortedTables(catalog)
	for _, table := range tables {
		g.writeMySQLTable(buf, table)
		buf.WriteString("\n")
	}

	for _, idx := range tableIndexes(catalog) {
		if !idx.Unique {
			buf.WriteString(g.generateMySQLIndex(idx, catalog))
			buf.WriteString("\n")
		}
	}

	for _, table := range tables {
		for _, idx := range table.Indexes {
			if idx.Unique {
				buf.WriteString(g.generateMySQLUniqueIndex(table.Name, idx))
				buf.WriteString("\n")
			}
		}
	}

	buf.WriteString("SET FOREIGN_KEY_CHECKS = 1;\n")
}

func (g *Generator) writeMySQLTable(buf *bytes.Buffer, table *model.Table) {
	buf.WriteString("DROP TABLE IF EXISTS ")
	buf.WriteString(table.Name)
	buf.WriteString(";\n")

	buf.WriteString("CREATE TABLE ")
	if g.emitIFNotExists {
		buf.WriteString("IF NOT EXISTS ")
	}
	buf.WriteString(table.Name)
	buf.WriteString(" (\n")

	var clauses []string
	for _, col := range table.Columns {
		clause := "    " + g.mysqlColumnDefinition(col)
		clauses = append(clauses, clause)
	}

	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := strings.Join(table.PrimaryKey.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    PRIMARY KEY (%s)", pkCols))
	}

	for _, fk := range table.ForeignKeys {
		refCols := strings.Join(fk.Ref.Columns, ", ")
		fkCols := strings.Join(fk.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    FOREIGN KEY (%s) REFERENCES %s(%s)", fkCols, fk.Ref.Table, refCols))
	}

	for _, uk := range table.UniqueKeys {
		cols := strings.Join(uk.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    UNIQUE KEY %s (%s)", sanitizeName(uk.Name), cols))
	}

	for i, clause := range clauses {
		buf.WriteString(clause)
		if i < len(clauses)-1 {
			buf.WriteString(",")
		}
		buf.WriteString("\n")
	}

	buf.WriteString(") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n")
}

func (g *Generator) mysqlColumnDefinition(col *model.Column) string {
	var parts []string

	parts = append(parts, col.Name)
	parts = append(parts, g.mysqlColumnType(col.Type))

	if col.NotNull {
		parts = append(parts, "NOT NULL")
	} else {
		parts = append(parts, "NULL")
	}

	if col.Default != nil {
		parts = append(parts, "DEFAULT "+g.mysqlDefaultValue(col.Default))
	}

	if strings.ToUpper(col.Name) == "ID" || strings.HasSuffix(strings.ToLower(col.Type), "autoincrement") {
		parts = append(parts, "AUTO_INCREMENT")
	}

	return strings.Join(parts, " ")
}

func (g *Generator) mysqlColumnType(typ string) string {
	upper := strings.ToUpper(typ)
	switch upper {
	case "INTEGER", "INT", "BIGINT", "SMALLINT", "TINYINT":
		return "BIGINT"
	case "REAL", "FLOAT", "DOUBLE", "DECIMAL", "NUMERIC":
		return "DOUBLE"
	case "TEXT", "VARCHAR", "CHAR", "CLOB":
		if strings.HasPrefix(upper, "VARCHAR") {
			return typ
		}
		if strings.HasPrefix(upper, "CHAR") {
			return typ
		}
		return "TEXT"
	case "BLOB":
		return "BLOB"
	case "BOOLEAN", "BOOL":
		return "TINYINT(1)"
	case "DATETIME", "TIMESTAMP":
		return "DATETIME"
	case "DATE":
		return "DATE"
	case "TIME":
		return "TIME"
	case "JSON":
		return "JSON"
	default:
		return typ
	}
}

func (g *Generator) mysqlDefaultValue(v *model.Value) string {
	switch v.Kind {
	case model.ValueKindNumber:
		return v.Text
	case model.ValueKindString:
		return "'" + v.Text + "'"
	case model.ValueKindKeyword:
		upper := strings.ToUpper(v.Text)
		if upper == "CURRENT_TIMESTAMP" || upper == "CURRENT_DATE" || upper == "CURRENT_TIME" {
			return upper
		}
		return v.Text
	case model.ValueKindBlob:
		return v.Text
	default:
		return "NULL"
	}
}

func (g *Generator) generateMySQLIndex(idx *model.Index, catalog *model.Catalog) string {
	tableName := findTableForIndex(catalog, idx)
	cols := strings.Join(idx.Columns, ", ")
	return fmt.Sprintf("CREATE INDEX %s ON %s(%s);", idx.Name, tableName, cols)
}

func (g *Generator) generateMySQLUniqueIndex(tableName string, idx *model.Index) string {
	cols := strings.Join(idx.Columns, ", ")
	return fmt.Sprintf("CREATE UNIQUE INDEX %s ON %s(%s);", idx.Name, tableName, cols)
}

func (g *Generator) generateMySQLView(buf *bytes.Buffer, view *model.View) {
	buf.WriteString("CREATE OR REPLACE VIEW ")
	buf.WriteString(view.Name)
	buf.WriteString(" AS\n")
	buf.WriteString(view.SQL)
	buf.WriteString(";\n")
}

func (g *Generator) sortedTables(catalog *model.Catalog) []*model.Table {
	tables := make([]*model.Table, 0, len(catalog.Tables))
	for _, t := range catalog.Tables {
		tables = append(tables, t)
	}
	slices.SortFunc(tables, func(a, b *model.Table) int {
		return strings.Compare(a.Name, b.Name)
	})
	return tables
}

func tableIndexes(catalog *model.Catalog) []*model.Index {
	idxMap := make(map[string]*model.Index)
	for _, t := range catalog.Tables {
		for _, idx := range t.Indexes {
			if _, exists := idxMap[idx.Name]; !exists {
				idxMap[idx.Name] = idx
			}
		}
	}
	idxs := make([]*model.Index, 0, len(idxMap))
	for _, idx := range idxMap {
		idxs = append(idxs, idx)
	}
	return idxs
}

func findTableForIndex(catalog *model.Catalog, idx *model.Index) string {
	for _, t := range catalog.Tables {
		if slices.Contains(t.Indexes, idx) {
			return t.Name
		}
	}
	return ""
}

func sanitizeName(name string) string {
	return strings.ReplaceAll(name, "-", "_")
}

func (g *Generator) generatePostgresSchema(buf *bytes.Buffer, catalog *model.Catalog) {
	buf.WriteString("-- Auto-generated schema for ")
	buf.WriteString(string(g.dialect))
	buf.WriteString("\n")
	buf.WriteString("-- Generated by db-catalyst\n\n")

	tables := g.sortedTables(catalog)
	for _, table := range tables {
		g.writePostgresTable(buf, table)
		buf.WriteString("\n")
	}

	for _, idx := range tableIndexes(catalog) {
		if !idx.Unique {
			buf.WriteString(g.generatePostgresIndex(idx, catalog))
			buf.WriteString("\n")
		}
	}

	for _, table := range tables {
		for _, idx := range table.Indexes {
			if idx.Unique {
				buf.WriteString(g.generatePostgresUniqueIndex(table.Name, idx))
				buf.WriteString("\n")
			}
		}
	}
}

func (g *Generator) writePostgresTable(buf *bytes.Buffer, table *model.Table) {
	buf.WriteString("DROP TABLE IF EXISTS ")
	buf.WriteString(table.Name)
	buf.WriteString(";\n")

	buf.WriteString("CREATE TABLE ")
	if g.emitIFNotExists {
		buf.WriteString("IF NOT EXISTS ")
	}
	buf.WriteString(table.Name)
	buf.WriteString(" (\n")

	var clauses []string
	for _, col := range table.Columns {
		clause := "    " + g.postgresColumnDefinition(col)
		clauses = append(clauses, clause)
	}

	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := strings.Join(table.PrimaryKey.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    PRIMARY KEY (%s)", pkCols))
	}

	for _, fk := range table.ForeignKeys {
		refCols := strings.Join(fk.Ref.Columns, ", ")
		fkCols := strings.Join(fk.Columns, ", ")
		clauses = append(clauses, fmt.Sprintf("    FOREIGN KEY (%s) REFERENCES %s(%s)", fkCols, fk.Ref.Table, refCols))
	}

	for _, uk := range table.UniqueKeys {
		cols := strings.Join(uk.Columns, ", ")
		constraintName := uk.Name
		if constraintName == "" {
			constraintName = fmt.Sprintf("%s_%s_key", table.Name, strings.Join(uk.Columns, "_"))
		}
		clauses = append(clauses, fmt.Sprintf("    CONSTRAINT %s UNIQUE (%s)", sanitizeName(constraintName), cols))
	}

	for i, clause := range clauses {
		buf.WriteString(clause)
		if i < len(clauses)-1 {
			buf.WriteString(",")
		}
		buf.WriteString("\n")
	}

	buf.WriteString(");\n")
}

func (g *Generator) postgresColumnDefinition(col *model.Column) string {
	var parts []string

	parts = append(parts, col.Name)
	parts = append(parts, g.postgresColumnType(col.Type))

	if col.NotNull {
		parts = append(parts, "NOT NULL")
	} else {
		parts = append(parts, "NULL")
	}

	if col.Default != nil {
		parts = append(parts, "DEFAULT "+g.postgresDefaultValue(col.Default))
	}

	if strings.ToUpper(col.Name) == "ID" || strings.HasSuffix(strings.ToLower(col.Type), "autoincrement") {
		parts = append(parts, "GENERATED ALWAYS AS IDENTITY")
	}

	return strings.Join(parts, " ")
}

func (g *Generator) postgresColumnType(typ string) string {
	upper := strings.ToUpper(typ)
	switch upper {
	case "INTEGER", "INT", "INT4":
		return "INTEGER"
	case "BIGINT", "INT8":
		return "BIGINT"
	case "SMALLINT", "INT2":
		return "SMALLINT"
	case "REAL", "FLOAT4":
		return "REAL"
	case "DOUBLE", "FLOAT8", "DOUBLE PRECISION":
		return "DOUBLE PRECISION"
	case "DECIMAL", "NUMERIC":
		return "NUMERIC"
	case "TEXT", "VARCHAR", "CHAR", "CLOB":
		if strings.HasPrefix(upper, "VARCHAR") {
			return typ
		}
		if strings.HasPrefix(upper, "CHAR") {
			return typ
		}
		return "TEXT"
	case "BLOB", "BYTEA":
		return "BYTEA"
	case "BOOLEAN", "BOOL":
		return "BOOLEAN"
	case "DATETIME", "TIMESTAMP":
		return "TIMESTAMP"
	case "DATE":
		return "DATE"
	case "TIME":
		return "TIME"
	case "JSON":
		return "JSON"
	case "JSONB":
		return "JSONB"
	case "UUID":
		return "UUID"
	case "SERIAL":
		return "SERIAL"
	case "BIGSERIAL":
		return "BIGSERIAL"
	case "SERIAL4":
		return "INTEGER"
	case "SERIAL8":
		return "BIGINT"
	default:
		return typ
	}
}

func (g *Generator) postgresDefaultValue(v *model.Value) string {
	switch v.Kind {
	case model.ValueKindNumber:
		return v.Text
	case model.ValueKindString:
		return "'" + v.Text + "'"
	case model.ValueKindKeyword:
		upper := strings.ToUpper(v.Text)
		if upper == "CURRENT_TIMESTAMP" || upper == "CURRENT_DATE" || upper == "CURRENT_TIME" {
			return upper
		}
		return v.Text
	case model.ValueKindBlob:
		return v.Text
	default:
		return "NULL"
	}
}

func (g *Generator) generatePostgresIndex(idx *model.Index, catalog *model.Catalog) string {
	tableName := findTableForIndex(catalog, idx)
	cols := strings.Join(idx.Columns, ", ")
	return fmt.Sprintf("CREATE INDEX %s ON %s(%s);", idx.Name, tableName, cols)
}

func (g *Generator) generatePostgresUniqueIndex(tableName string, idx *model.Index) string {
	cols := strings.Join(idx.Columns, ", ")
	return fmt.Sprintf("CREATE UNIQUE INDEX %s ON %s(%s);", idx.Name, tableName, cols)
}

func (g *Generator) generatePostgresView(buf *bytes.Buffer, view *model.View) {
	buf.WriteString("CREATE OR REPLACE VIEW ")
	buf.WriteString(view.Name)
	buf.WriteString(" AS\n")
	buf.WriteString(view.SQL)
	buf.WriteString(";\n")
}
